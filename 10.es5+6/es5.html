<!--"use strict";-->

<!--语法和行为改变-->
<!--必须用var声明变量-->
<!--在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。-->

<!--禁止自定义的函数中的this指向window-->
<!--var foo = function () {-->
<!--console.log(this);-->
<!--}-->
<!--foo();-->
<!--普通模式打印的是window。严格模式下打印的是undefined。-->

<!--创建eval作用域-->
<!--禁止使用with语句-->
<!--因为with语句无法在编译时就确定，属性到底归属哪个对象-->
<!--构造函数必须通过new实例化对象，否则报错。因为this为undefined，此时无法设置属性。-->
<!--为了让代码更安全，禁止函数内部遍历调用栈-->
<!--严格模式下无法删除变量-->

<!--对象不能有重名的属性-->
<!--普通模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。-->
<!--严格模式下，对禁止扩展的对象添加新属性，会报错。-->
<!--普通模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。-->
<!--普通模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，多个重名的参数属于语法错误。-->


<!--函数声明在顶层-->
<!--将来Javascript的新版本会引入"块级作用域"。为了与新版本接轨，-->
<!--严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，-->
<!--不允许在非函数的代码块内声明函数。-->


<!--新增关键字-->
<!--为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：
implements, interface, let, package, private, protected, public, static, yield。-->

<!--json对象-->
<!--js对象(数组) &ndash;&gt; json对象(数组)：-->
<!--JSON.stringify(obj/arr)-->

<!--json对象(数组) &ndash;&gt; js对象(数组)：-->
<!--JSON.parse(json)-->

<!--object的扩展一-->
<!--Object.create(prototype, [descriptors])-->
<!--带第一个参数和带两个参数的不同情况-->

<!--Object.defineProperties(object, descriptors)为指定对象定义扩展多个属性。-->

<!--object的扩展二-->
<!--obj对象本身就自带了两个方法。格式如下：-->
<!--get 属性名(){} 用来得到当前属性值的回调函数-->
<!--set 属性名(){} 用来监视当前属性值变化的回调函数-->



<!--数组的扩展-->
<!--方法1：-->
<!--Array.prototype.indexOf(value)-->
<!--作用：获取 value 在数组中的第一个下标。-->

<!--方法2：-->
<!--Array.prototype.lastIndexOf(value)-->
<!--作用：获取 value 在数组中的最后一个下标。-->

<!--方法3：遍历数组-->
<!--Array.prototype.forEach(function(item, index){})-->

<!--方法4：-->
<!--Array.prototype.map(function(item, index){})-->
<!--作用：遍历数组返回一个新的数组，返回的是加工之后的新数组。-->

<!--方法5：-->
<!--Array.prototype.filter(function(item, index){})-->
<!--作用：遍历过滤出一个新的子数组，返回条件为true的值。-->



<!--函数function的扩展：bind()-->
<!--Function.prototype.bind(obj)作用：将函数内的this绑定为obj, 并将函数返回。-->
<!--面试题: call()、apply()和bind()的区别：-->

<!--都能改变this的指向-->
<!--call()/apply()是立即调用函数-->
<!--bind()：绑定完this后，不会立即调用当前函数，而是将函数返回，因此后面还需要再加()才能调用。-->
<!--PS：bind()传参的方式和call()一样。-->
<!--分析：-->
<!--为什么ES5中要加入bind()方法来改变this的指向呢？因为bind()不会立即调用当前函数。-->
<!--bind()通常使用在回调函数中，因为回调函数并不会立即调用。如果你希望在回调函数中改变this，不妨使用bind()。-->